[defn build-prev-next-list [ctx]
      "Build the list linking each page to the next/previous one, which might"
      "not be displayed on every page but will be calculated nonetheless"
      :export
      [def nav @[]]
      [def l [-> [tree/values [tree/ref ctx :frontmatter]]
                 [list/sort [fn [a b] [< [tree/ref a :href]
                                         [tree/ref b :href]]]]]]
      [def c l]
      [while [cdr c]
        [when [== [path/dirname [tree/ref [car c] :href]]
                  [path/dirname [tree/ref [cadr c] :href]]]
          [def cur-href [string->keyword [tree/ref [cadr c] :href]]]
          [def prev-href [tree/ref [car c] :href]]
          [when-not [tree/ref nav cur-href] [tree/set! nav cur-href @[:prev #nil :next #nil]]]
          [tree/set! [tree/ref nav cur-href] :prev prev-href]

          [def cur-href [string->keyword [tree/ref [car c] :href]]]
          [def next-href [tree/ref [cadr c] :href]]
          [when-not [tree/ref nav cur-href] [tree/set! nav cur-href @[:prev #nil :next #nil]]]
          [tree/set! [tree/ref nav cur-href] :next next-href]]
        [cdr! c]]
      [tree/set! ctx :prev-next-nav nav]]

[defn build [ctx depth prefix category]
      "Build up a navigation and return a list of trees, describing the entries"
      :export
      [def l [-> [tree/values [tree/ref ctx :frontmatter]]
                 [filter [fn [a] [not [tree/ref a :hide-in-nav]]]]]]
      [when depth
        [set! l [filter l [fn [a] [== depth [tree/ref a :depth]]]]]]
      [when prefix
        [set! l [filter l [fn [a] [== prefix [cut [tree/ref a :href] 0 [buffer/length prefix]]]]]]]
      [when category
        [set! l [filter l [fn [a] [== category [tree/ref a :category]]]]]]
      [list/sort l [fn [a b] [< [tree/ref a :href]
                                [tree/ref b :href]]]]]
